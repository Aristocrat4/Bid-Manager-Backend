# AutoBid Manager Backend - AI Development Rules

This document establishes coding standards, architectural patterns, and security best practices for the AutoBid Manager NestJS backend.

## Architecture Principles

### 1. Dependency Injection
- **ALWAYS** use NestJS dependency injection
- **NEVER** instantiate services with `new` keyword
- Inject dependencies through constructor
- Use `@Injectable()` decorator on all services
- Use `@Inject()` when injecting non-class dependencies

### 2. Clean Architecture
Follow the layered architecture pattern:
```
Controller → Service → Repository (Mongoose Model)
```

- **Controllers:** Handle HTTP requests, validate input (DTOs), return responses
- **Services:** Contain business logic, orchestrate data operations
- **Repositories:** Direct database operations (Mongoose models)

### 3. Module Organization
```
src/
├── modules/
│   ├── auth/
│   │   ├── auth.controller.ts
│   │   ├── auth.service.ts
│   │   ├── auth.module.ts
│   │   ├── dto/
│   │   │   └── login.dto.ts
│   │   ├── guards/
│   │   │   └── jwt-auth.guard.ts
│   │   └── strategies/
│   │       └── jwt.strategy.ts
│   ├── companies/
│   ├── users/
│   ├── bids/
│   └── wins/
├── common/
│   ├── decorators/
│   ├── filters/
│   ├── guards/
│   ├── interceptors/
│   ├── pipes/
│   └── services/
├── config/
└── database/
    └── schemas/
```

## Naming Conventions

### Files
- **kebab-case:** `user.service.ts`, `create-user.dto.ts`, `jwt-auth.guard.ts`

### Classes
- **PascalCase:** `UserService`, `CreateUserDto`, `JwtAuthGuard`
- **Suffixes:** Use meaningful suffixes
  - Services: `UserService`
  - Controllers: `UserController`
  - DTOs: `CreateUserDto`, `UpdateUserDto`
  - Guards: `JwtAuthGuard`
  - Strategies: `JwtStrategy`

### Methods
- **camelCase:** `getUserById`, `createUser`, `validateCredentials`
- **Prefixes:**
  - `get`: Retrieve data (e.g., `getUser`)
  - `find`: Search/query (e.g., `findByEmail`)
  - `create`: Create new entity
  - `update`: Modify existing entity
  - `delete`: Remove entity (soft delete preferred)
  - `validate`: Check validity
  - `check`: Boolean check (e.g., `checkExists`)

### Constants
- **UPPER_SNAKE_CASE:** `MAX_RETRY_COUNT`, `DEFAULT_PAGE_SIZE`

## TypeScript Best Practices

### 1. Type Safety
```typescript
// ✅ GOOD: Explicit types
async getUserById(id: string): Promise<User> {
  const user = await this.userModel.findById(id);
  if (!user) {
    throw new NotFoundException('User not found');
  }
  return user;
}

// ❌ BAD: Implicit any
async getUserById(id) {
  return await this.userModel.findById(id);
}
```

### 2. No `any` Type
```typescript
// ✅ GOOD: Proper types
interface LoginResponse {
  success: boolean;
  data: {
    accessToken: string;
    user: UserDto;
  };
}

// ❌ BAD: Using any
function login(): any {
  return { success: true, data: {} };
}
```

### 3. Null Safety
```typescript
// ✅ GOOD: Explicit null handling
async getCompany(id: string): Promise<Company | null> {
  const company = await this.companyModel.findById(id);
  return company ?? null;
}

// ❌ BAD: Assuming non-null
async getCompany(id: string): Promise<Company> {
  return await this.companyModel.findById(id); // Could be null!
}
```

## Data Transfer Objects (DTOs)

### 1. Always Use DTOs
- **NEVER** accept raw objects in controllers
- **ALWAYS** validate with class-validator

```typescript
// ✅ GOOD: Validated DTO
export class CreateUserDto {
  @IsString()
  @IsNotEmpty()
  @MinLength(3)
  username: string;

  @IsString()
  @MinLength(6)
  password: string;

  @IsString()
  @IsNotEmpty()
  displayName: string;

  @IsMongoId()
  companyId: string;

  @IsString()
  @IsOptional()
  buyerNumber?: string;
}

// ❌ BAD: No validation
export class CreateUserDto {
  username: string;
  password: string;
}
```

### 2. Validation Decorators
Always use appropriate validators:
- `@IsString()` - String values
- `@IsNumber()` - Numeric values
- `@IsEmail()` - Email addresses
- `@IsMongoId()` - MongoDB ObjectIds
- `@IsBoolean()` - Boolean values
- `@IsDate()` - Date values
- `@IsOptional()` - Optional fields
- `@MinLength(n)` - Minimum string length
- `@MaxLength(n)` - Maximum string length
- `@Min(n)` - Minimum number value
- `@Max(n)` - Maximum number value

## Security Best Practices

### 1. Password Security
```typescript
// ✅ GOOD: Hash passwords with bcrypt
import * as bcrypt from 'bcrypt';

async createUser(dto: CreateUserDto): Promise<User> {
  const hashedPassword = await bcrypt.hash(dto.password, 10);
  const user = new this.userModel({
    ...dto,
    password: hashedPassword,
  });
  return await user.save();
}

// ✅ GOOD: Compare passwords
async validatePassword(plainPassword: string, hashedPassword: string): Promise<boolean> {
  return await bcrypt.compare(plainPassword, hashedPassword);
}

// ❌ BAD: Store plain text passwords
async createUser(dto: CreateUserDto): Promise<User> {
  return await this.userModel.create(dto);
}
```

### 2. Encryption for Sensitive Data
```typescript
// ✅ GOOD: Encrypt sensitive credentials
async createCompany(dto: CreateCompanyDto): Promise<Company> {
  const encryptedPassword = this.encryptionService.encrypt(dto.copartPassword);
  const company = new this.companyModel({
    ...dto,
    copartPassword: encryptedPassword,
  });
  return await company.save();
}

// ❌ BAD: Store sensitive data in plain text
async createCompany(dto: CreateCompanyDto): Promise<Company> {
  return await this.companyModel.create(dto);
}
```

### 3. Never Expose Sensitive Data
```typescript
// ✅ GOOD: Exclude passwords from responses
async findByCompanyId(companyId: string): Promise<User[]> {
  return await this.userModel
    .find({ companyId })
    .select('-password')
    .exec();
}

// ❌ BAD: Return full user objects with passwords
async findByCompanyId(companyId: string): Promise<User[]> {
  return await this.userModel.find({ companyId });
}
```

### 4. Always Protect Routes
```typescript
// ✅ GOOD: Use guards on protected routes
@Controller('users')
@UseGuards(JwtAuthGuard)
export class UsersController {
  @Post()
  async create(@Body() dto: CreateUserDto) {
    return await this.usersService.create(dto);
  }
}

// ❌ BAD: No authentication
@Controller('users')
export class UsersController {
  @Post()
  async create(@Body() dto: CreateUserDto) {
    return await this.usersService.create(dto);
  }
}
```

### 5. Input Validation
```typescript
// ✅ GOOD: Validate all inputs
@Post('bid/log')
@UseGuards(JwtAuthGuard)
async logBid(@Body() dto: LogBidDto, @Req() req: Request) {
  return await this.bidsService.logBid(req.user.id, req.user.companyId, dto);
}

// ❌ BAD: No validation
@Post('bid/log')
async logBid(@Body() dto: any, @Req() req: any) {
  return await this.bidsService.logBid(dto);
}
```

## Error Handling

### 1. Use NestJS Exceptions
```typescript
// ✅ GOOD: Proper exceptions
async getUserById(id: string): Promise<User> {
  const user = await this.userModel.findById(id);
  if (!user) {
    throw new NotFoundException(`User with ID ${id} not found`);
  }
  if (!user.isActive) {
    throw new UnauthorizedException('User account is deactivated');
  }
  return user;
}

// ❌ BAD: Generic errors
async getUserById(id: string): Promise<User> {
  const user = await this.userModel.findById(id);
  if (!user) {
    throw new Error('Not found');
  }
  return user;
}
```

### 2. Available Exceptions
- `NotFoundException` - Resource not found (404)
- `UnauthorizedException` - Authentication failed (401)
- `ForbiddenException` - Insufficient permissions (403)
- `BadRequestException` - Invalid input (400)
- `ConflictException` - Resource conflict (409)
- `InternalServerErrorException` - Server error (500)

### 3. Never Expose Sensitive Info in Errors
```typescript
// ✅ GOOD: Safe error messages
catch (error) {
  this.logger.error('Failed to decrypt password', error.stack);
  throw new InternalServerErrorException('Failed to retrieve credentials');
}

// ❌ BAD: Exposing internal details
catch (error) {
  throw new InternalServerErrorException(error.message);
}
```

## Database Best Practices

### 1. Schema Design
```typescript
// ✅ GOOD: Complete schema with indexes
@Schema({ timestamps: true })
export class User extends Document {
  @Prop({ required: true, index: true })
  companyId: Types.ObjectId;

  @Prop({ required: true, unique: true, index: true })
  username: string;

  @Prop({ required: true })
  password: string;

  @Prop({ required: true })
  displayName: string;

  @Prop()
  buyerNumber?: string;

  @Prop({ default: true, index: true })
  isActive: boolean;
}

export const UserSchema = SchemaFactory.createForClass(User);

// Create compound indexes
UserSchema.index({ companyId: 1, username: 1 }, { unique: true });
```

### 2. Use Lean Queries for Read-Only
```typescript
// ✅ GOOD: Use lean() for read-only operations
async findByCompanyId(companyId: string): Promise<User[]> {
  return await this.userModel
    .find({ companyId })
    .select('-password')
    .lean()
    .exec();
}

// ❌ BAD: Full Mongoose documents when not needed
async findByCompanyId(companyId: string): Promise<User[]> {
  return await this.userModel.find({ companyId });
}
```

### 3. Avoid N+1 Queries
```typescript
// ✅ GOOD: Use populate
async getCompanyBids(companyId: string): Promise<Bid[]> {
  return await this.bidModel
    .find({ companyId })
    .populate('userId', 'username displayName')
    .exec();
}

// ❌ BAD: Fetch users in loop
async getCompanyBids(companyId: string): Promise<Bid[]> {
  const bids = await this.bidModel.find({ companyId });
  for (const bid of bids) {
    bid.user = await this.userModel.findById(bid.userId);
  }
  return bids;
}
```

## API Response Format

### Standardized Response
All API responses should follow this format:

```typescript
interface ApiResponse<T> {
  success: boolean;
  data?: T;
  message?: string;
  errors?: any;
}

// ✅ GOOD: Standardized success response
@Post('login')
async login(@Body() dto: LoginDto): Promise<ApiResponse<LoginData>> {
  const result = await this.authService.login(dto);
  return {
    success: true,
    data: result,
  };
}

// ✅ GOOD: Standardized error response (via exception filter)
{
  success: false,
  message: 'User not found',
  errors: {
    statusCode: 404,
    timestamp: '2026-01-25T10:00:00.000Z',
    path: '/api/users/123'
  }
}
```

## Code Examples

### Complete Service Example
```typescript
import { Injectable, NotFoundException, ConflictException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import * as bcrypt from 'bcrypt';
import { User } from '../database/schemas/user.schema';
import { CreateUserDto } from './dto/create-user.dto';

@Injectable()
export class UsersService {
  constructor(
    @InjectModel(User.name) private readonly userModel: Model<User>,
  ) {}

  async create(dto: CreateUserDto): Promise<Omit<User, 'password'>> {
    // Check if username exists
    const existingUser = await this.userModel.findOne({ username: dto.username });
    if (existingUser) {
      throw new ConflictException('Username already exists');
    }

    // Hash password
    const hashedPassword = await bcrypt.hash(dto.password, 10);

    // Create user
    const user = new this.userModel({
      ...dto,
      password: hashedPassword,
      isActive: true,
    });

    const savedUser = await user.save();

    // Remove password from response
    const { password, ...userWithoutPassword } = savedUser.toObject();
    return userWithoutPassword;
  }

  async findById(id: string): Promise<Omit<User, 'password'>> {
    const user = await this.userModel
      .findById(id)
      .select('-password')
      .lean()
      .exec();

    if (!user) {
      throw new NotFoundException('User not found');
    }

    return user;
  }

  async findByCompanyId(companyId: string): Promise<Omit<User, 'password'>[]> {
    return await this.userModel
      .find({ companyId, isActive: true })
      .select('-password')
      .sort({ createdAt: -1 })
      .lean()
      .exec();
  }

  async deactivate(id: string): Promise<void> {
    const user = await this.userModel.findById(id);
    if (!user) {
      throw new NotFoundException('User not found');
    }

    user.isActive = false;
    await user.save();
  }
}
```

### Complete Controller Example
```typescript
import {
  Controller,
  Get,
  Post,
  Delete,
  Body,
  Param,
  UseGuards,
  HttpCode,
  HttpStatus,
} from '@nestjs/common';
import { UsersService } from './users.service';
import { CreateUserDto } from './dto/create-user.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';

@Controller('users')
@UseGuards(JwtAuthGuard)
export class UsersController {
  constructor(private readonly usersService: UsersService) {}

  @Post()
  @HttpCode(HttpStatus.CREATED)
  async create(@Body() dto: CreateUserDto) {
    const user = await this.usersService.create(dto);
    return {
      success: true,
      data: user,
      message: 'User created successfully',
    };
  }

  @Get('company/:companyId')
  async findByCompany(@Param('companyId') companyId: string) {
    const users = await this.usersService.findByCompanyId(companyId);
    return {
      success: true,
      data: users,
    };
  }

  @Get(':id')
  async findOne(@Param('id') id: string) {
    const user = await this.usersService.findById(id);
    return {
      success: true,
      data: user,
    };
  }

  @Delete(':id')
  @HttpCode(HttpStatus.OK)
  async deactivate(@Param('id') id: string) {
    await this.usersService.deactivate(id);
    return {
      success: true,
      message: 'User deactivated successfully',
    };
  }
}
```

## Critical Rules (NEVER VIOLATE)

### ❌ NEVER
1. **NEVER** use `any` type
2. **NEVER** store passwords in plain text
3. **NEVER** skip input validation
4. **NEVER** expose sensitive data in responses
5. **NEVER** commit secrets to git
6. **NEVER** log decrypted passwords or sensitive data
7. **NEVER** bypass authentication guards
8. **NEVER** hard-code configuration values
9. **NEVER** ignore error handling
10. **NEVER** use `console.log` (use NestJS Logger)

### ✅ ALWAYS
1. **ALWAYS** use DTOs with validation decorators
2. **ALWAYS** hash passwords with bcrypt (10 rounds)
3. **ALWAYS** encrypt sensitive credentials (AES-256-GCM)
4. **ALWAYS** use dependency injection
5. **ALWAYS** handle errors with proper exceptions
6. **ALWAYS** use TypeScript strict mode
7. **ALWAYS** protect routes with guards
8. **ALWAYS** validate and sanitize inputs
9. **ALWAYS** exclude passwords from responses
10. **ALWAYS** follow single responsibility principle

## Logging

Use NestJS Logger instead of console.log:

```typescript
// ✅ GOOD: Use Logger
import { Logger } from '@nestjs/common';

export class UsersService {
  private readonly logger = new Logger(UsersService.name);

  async create(dto: CreateUserDto) {
    this.logger.log(`Creating user: ${dto.username}`);
    // ... implementation
  }

  async handleError(error: Error) {
    this.logger.error('Failed to create user', error.stack);
    throw new InternalServerErrorException('User creation failed');
  }
}

// ❌ BAD: Use console.log
console.log('Creating user');
```

## Testing

Write unit tests for all services:

```typescript
describe('UsersService', () => {
  let service: UsersService;
  let model: Model<User>;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        UsersService,
        {
          provide: getModelToken(User.name),
          useValue: mockModel,
        },
      ],
    }).compile();

    service = module.get<UsersService>(UsersService);
    model = module.get<Model<User>>(getModelToken(User.name));
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  it('should create a user with hashed password', async () => {
    const dto: CreateUserDto = {
      username: 'testuser',
      password: 'password123',
      displayName: 'Test User',
      companyId: '507f1f77bcf86cd799439011',
    };

    const result = await service.create(dto);

    expect(result).toBeDefined();
    expect(result.password).toBeUndefined();
    expect(result.username).toBe('testuser');
  });
});
```

---

## Summary

Following these rules ensures:
- ✅ Type-safe, maintainable code
- ✅ Secure password and credential handling
- ✅ Consistent API design
- ✅ Proper error handling
- ✅ Optimized database queries
- ✅ Protected routes and resources
- ✅ Clean, testable architecture

**When in doubt, prioritize security and type safety.**
